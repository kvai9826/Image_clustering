elif menu == "Database Viewer":
    st.title("Database Viewer")

    # Load records
    df = pd.read_sql_query("""
        SELECT id, unique_image_id, sub_cluster_id, customer_id, order_id,
               ip_country_code, billing_country_code, shipping_country_code,
               credit_card_country_code, fast_lane, isfba, has_prime,
               gl_code, payment_method, issuing_bank, item_name, value_usd, description,
               damage_classification, chat_text, image_hash
        FROM records
    """, conn)

    if df.empty:
        st.info("No records found.")
    else:
        # Top search controls
        q_col, img_col, chat_col, dl_col = st.columns([3, 1, 1, 1])
        q = q_col.text_input("Search (any field or chat)")
        show_img = img_col.toggle("Show Images", True)
        show_chat = chat_col.toggle("Show Chat", False)

        csv = df.to_csv(index=False).encode("utf-8")
        dl_col.download_button("Download CSV", csv, "claims.csv")

        # Search filter
        if q:
            ql = q.lower()
            df = df[df.apply(lambda r: ql in " ".join(map(str, r.values)).lower(), axis=1)]

        # Clean numeric values
        df["value_usd"] = pd.to_numeric(df["value_usd"], errors="coerce").fillna(0)

        # ----------------------------
        # Refund Status Logic
        # ----------------------------
        df["refund_status"] = None
        df = df.sort_values(by="id", ascending=True)

        for cluster_id, group in df.groupby("unique_image_id"):
            min_id = group["id"].min()
            df.loc[df["id"] == min_id, "refund_status"] = "Approved"
            df.loc[(df["unique_image_id"] == cluster_id) & (df["id"] != min_id), "refund_status"] = "Denied"

        # ----------------------------
        # Display Clusters
        # ----------------------------
        for uid in df["unique_image_id"].unique():
            cluster_df = df[df["unique_image_id"] == uid].copy()

            # Cluster stats
            total_cluster_value = cluster_df["value_usd"].sum()
            total_subclusters = cluster_df["sub_cluster_id"].nunique()
            total_accounts = len(cluster_df)
            total_savings = cluster_df.loc[cluster_df["refund_status"] == "Denied", "value_usd"].sum()

            # Cluster ID in green
            st.markdown(f"**Main Cluster:** :green[{uid}]")

            # Clean cluster summary
            cluster_summary = (
                f"Total Cluster Value: ${total_cluster_value:,.2f}    |    "
                f"Total Subclusters: {total_subclusters}    |    "
                f"Total Accounts: {total_accounts}    |    "
                f"Savings: ${total_savings:,.2f}"
            )
            st.text(cluster_summary)

            # ----------------------------
            # Subclusters within cluster
            # ----------------------------
            for sc in cluster_df["sub_cluster_id"].unique():
                sub = cluster_df[cluster_df["sub_cluster_id"] == sc].copy()

                total_value = sub["value_usd"].sum()
                account_count = len(sub)
                sub_savings = sub.loc[sub["refund_status"] == "Denied", "value_usd"].sum()

                sub_summary = (
                    f"Subcluster: {sc}    |    Accounts: {account_count}    |    "
                    f"Total: ${total_value:,.2f}    |    Savings: ${sub_savings:,.2f}"
                )
                st.text(sub_summary)

                # Clean column ordering
                sub_disp = sub.drop(columns=["unique_image_id", "sub_cluster_id", "image_hash"], errors="ignore")

                if not show_chat:
                    sub_disp = sub_disp.drop(columns=["chat_text"], errors="ignore")

                desired_order = [
                    "refund_status", "customer_id", "order_id",
                    "ip_country_code", "billing_country_code", "shipping_country_code", "credit_card_country_code",
                    "fast_lane", "isfba", "has_prime",
                    "gl_code", "payment_method", "issuing_bank",
                    "item_name", "value_usd", "damage_classification",
                    "description"
                ]
                final_cols = [col for col in desired_order if col in sub_disp.columns]

                # --- FIX START: Replace st.dataframe with a manual row-by-row grid ---
                # This ensures each data row is rendered with its corresponding image for proper alignment.

                # 1. Define column ratios to approximate the original layout.
                # The first list of ratios is for the data columns, and the last element is for the image column.
                num_data_cols = len(final_cols)
                table_width_ratio = 5
                image_width_ratio = 1.5
                data_col_ratios = [table_width_ratio / num_data_cols] * num_data_cols
                
                # Add an extra column for the image if enabled
                column_ratios = data_col_ratios
                if show_img:
                    column_ratios += [image_width_ratio]


                # 2. Display headers for the data table (and image column if shown)
                header_cols = st.columns(column_ratios)
                for i, col_name in enumerate(final_cols):
                    header_cols[i].markdown(f"**{col_name.replace('_', ' ').title()}**")
                
                if show_img:
                    header_cols[-1].markdown("**Image**")
                
                st.divider()

                # 3. Iterate through each row of the subcluster to display it with its image
                for index, row in sub.iterrows():
                    row_cols = st.columns(column_ratios)
                    
                    # Populate data columns for the current row
                    for i, col_name in enumerate(final_cols):
                        val = row[col_name]
                        if col_name == 'refund_status':
                            color = "green" if val == "Approved" else ("red" if val == "Denied" else "black")
                            row_cols[i].markdown(f'<span style="color: {color};">{val}</span>', unsafe_allow_html=True)
                        else:
                            row_cols[i].write(val)

                    # Populate image column for the current row
                    if show_img:
                        with row_cols[-1]:
                            p = os.path.join(IMAGE_FOLDER, f"{row['image_hash']}.png")
                            if os.path.exists(p):
                                st.image(p, width=40)
                            else:
                                st.empty() # Keep the space consistent if image is missing
                # --- FIX END ---

